

## 需要的信息来源

  

pnpm 中文文档 : https://www.pnpm.cn/

  

Vite 官方中文文档：https://vitejs.cn/vite3-cn/

  

## 新建 vite 项目

  

使用 pnpm 包管理器

  

```bash

pnpm create vite

```

  

需要填写你的项目名称，然后选择 Vue 与 TypeScript

  

```bash

√ Project name: ... your-project-name

√ Select a framework: » Vue

√ Select a variant: » TypeScript

```

  

目录结构

  

```text

│ .gitignore # git 忽略文件

│ index.html # 入口HTML

│ package.json # 项目配置文件

│ README.md

│ tsconfig.json # ts项目配置文件

│ tsconfig.node.json

│ vite.config.ts # vite 配置文件

│

│

├───public # 不打包的静态资源

│ vite.svg # 网站图标

│

└───src # 主目录

│ App.vue # 主组件

│ main.ts # 入口文件

│ style.css # 样式文件

│ vite-env.d.ts # vite环境配置文件

│

├───assets

│ vue.svg # 需要打包的静态资源

│

└───components # 组件目录

HelloWorld.vue # 组件

```

  

`tsconfig.json` 是 ts 项目的项目配置文件

  

[tsconfig.json 官方文档](https://www.tslang.cn/docs/handbook/tsconfig-json.html)

  

CSDN [你不知道的 tsconfig.json](https://blog.csdn.net/azl397985856/article/details/108090980?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-5&spm=1001.2101.3001.4242)

  

这里直接使用这些

  

`tsconfig.json`

  

```json

{

"compilerOptions": {

// 指定ECMAScript目标版本，esnext为最新版本

"target": "esnext",

// 指定生成哪个模块系统代码，esnext为最新版本

"module": "esnext",

// 决定如何处理模块。

"moduleResolution": "node",

// 启用所有严格类型检查选项。

"strict": true,

// 禁止对同一个文件的不一致的引用。

"forceConsistentCasingInFileNames": true,

// 允许从没有设置默认导出的模块中默认导入。这并不影响代码的输出，仅为了类型检查。

"allowSyntheticDefaultImports": true,

// 禁用函数参数双向协变检查。

"strictFunctionTypes": false,

// 在 .tsx文件里支持JSX

"jsx": "preserve",

// 解析非相对模块名的基准目录。查看 模块解析文档了解详情。

"baseUrl": ".",

// 允许编译javascript文件。

"allowJs": true,

// 生成相应的 .map文件。

"sourceMap": true,

"esModuleInterop": true,

"resolveJsonModule": true,

// 若有未使用的局部变量则抛错。

"noUnusedLocals": true,

// 若有未使用的参数则抛错。

"noUnusedParameters": true,

// 启用实验性的ES装饰器。

"experimentalDecorators": true,

// 编译过程中需要引入的库文件的列表。

"lib": ["dom", "esnext"],

// 要包含的类型声明文件名列表。

"types": ["vite/client"],

// 要包含的类型声明文件路径列表。

"typeRoots": ["./node_modules/@types/", "./types"],

"incremental": true,

// 在表达式和声明上有隐含的 any类型时报错。

"noImplicitAny": false,

// 忽略所有的声明文件（ *.d.ts）的类型检查。

"skipLibCheck": true,

// 模块名到基于 baseUrl的路径映射的列表。查看 模块解析文档了解详情。

"paths": {

"@/*": ["src/*"],

"#/*": ["types/*"]

}

},

// 指定一个匹配列表（属于自动指定该路径下的所有ts相关文件）

"include": [

"src/**/*.ts",

"src/**/*.d.ts",

"src/**/*.tsx",

"src/**/*.vue",

"types/**/*.d.ts",

"types/**/*.ts",

"mock/**/*.ts"

],

// 指定一个排除列表（include的反向操作）

"exclude": ["node_modules", "dist", "**/*.js"],

}

```

  

## 规范化插件

  

### 代码规范

  

参考信息： 知乎 [最全的Eslint配置模板，从此统一团队的编程习惯](https://zhuanlan.zhihu.com/p/87667635)

  

  

ESLint 是一个代码规范和错误检查工具，而prettier是帮助你格式化代码的工具，可以帮你把不规范的代码改掉，Stylelint 用于校验项目内部 css 的风格,加上编辑器的自动修复，可以很好的统一项目内部 css 风格

  

可以规范你的代码格式，可以统一团队代码风格

  

在项目中安装(本项目 ts) 安装到开发依赖，先安装 `ESLint` 与 `Prettier` 的依赖

  

```bash

pnpm i eslint babel-eslint eslint-define-config vue-eslint-parser eslint-plugin-vue @typescript-eslint/parser @typescript-eslint/eslint-plugin prettier eslint-config-prettier eslint-plugin-prettier pretty-quick jest eslint-plugin-jest -D

```

  

`eslint-plugin-vue` : ESlint 检查vue文件需要的依赖

  

`vue-eslint-parser` : vue的模板解析器

  

`eslint-define-config` : 提供了一些默认配置与 defineConfig 函数

  

`eslint-plugin-prettier` : 解决 prettier和ESLint之间有些规则冲突,例如定义函数时函数名与括号之间的空格

  

`prettier` : 格式化代码插件

  

`pretty-quick`: 可以使你在提交代码的时候格式化代码

  

  

#### ESlint

  

添加ESlint 规则配置文件`.eslintrc.cjs`

  

> 因为最新 vite 模板的 `package.json` 设置了 `"type": "module"` 后你的所有js文件默认使用ESM模块规范，不支持commonjs规范，所以必须显式的声明成xxx.cjs才能标识这个是用commonjs规范的，把你的配置都改成.cjs后缀

  

```js

// 详解配置https://www.bbsmax.com/A/QW5YV9eedm/

// @ts-check

const { defineConfig } = require("eslint-define-config");

module.exports = defineConfig({

// ↓默认情况下，ESLint 会在所有父级目录里寻找配置文件，一直到根目录。如果你想要你所有项目都遵循一个特定的约定时，这将会很有用，但有时候会导致意想不到的结果。为了将 ESLint 限制到一个特定的项目，在你项目根目录下的 package.json 文件或者 .eslintrc.* 文件里的 eslintConfig 字段下设置 "root": true。ESLint 一旦发现配置文件中有 "root": true，它就会停止在父级目录中寻找。

// 以当前目录为根目录，不再向上查找 .eslintrc.js

root: true,

// ↓指定你想启用的环境

env: {

browser: true,

node: true,

es6: true,

},

// ↓设置解析器

parser: "vue-eslint-parser",

// ↓解析器选项

parserOptions: {

// Typescript语法的解析器 项目地址： https://github.com/typescript-eslint/typescript-eslint/tree/main/packages/parser

parser: "@typescript-eslint/parser",

// 使用最新版

ecmaVersion: "latest",

sourceType: "module",

jsxPragma: "React",

ecmaFeatures: {

jsx: true,

},

},

extends: ["plugin:vue/vue3-recommended", "plugin:@typescript-eslint/recommended", "prettier", "plugin:prettier/recommended", "plugin:jest/recommended"],

// ↓自定义规则配置

rules: {

// ↓禁止使用@ts-ignore来消除ESLint检查

"@typescript-eslint/ban-ts-ignore": "off",

// ↓在函数和类方法上需要显式的返回类型

"@typescript-eslint/explicit-function-return-type": "off",

// ↓禁止使用any类型

"@typescript-eslint/no-explicit-any": "off",

// ↓除导入语句外，禁止使用require语句

"@typescript-eslint/no-var-requires": "off",

// ↓禁止使用空函数

"@typescript-eslint/no-empty-function": "off",

// ↓对自定义事件名称强制使用特定的大小写

"vue/custom-event-name-casing": "off",

// ↓禁止定义前使用

"no-use-before-define": "off",

// ↓在定义变量之前不允许使用变量

"@typescript-eslint/no-use-before-define": "off",

// ↓禁止使用@ts-注解

"@typescript-eslint/ban-ts-comment": "off",

// ↓禁止使用特定类型

"@typescript-eslint/ban-types": "off",

// ↓禁止使用!后缀运算符进行非null断言

"@typescript-eslint/no-non-null-assertion": "off",

// ↓在导出的函数和类的公共类方法上需要显式的返回值和参数类型

"@typescript-eslint/explicit-module-boundary-types": "off",

// // ↓禁止未使用的变量

"@typescript-eslint/no-unused-vars": [

"error",

{

argsIgnorePattern: "^_",

varsIgnorePattern: "^_",

},

],

// ↓禁止未使用的变量

"no-unused-vars": [

"error",

{

argsIgnorePattern: "^_",

varsIgnorePattern: "^_",

},

],

// ↓在函数括号前需要或不允许有空格

"space-before-function-paren": "off",

// ↓强制属性顺序

"vue/attributes-order": "off",

// ↓强制每个组件应位于其自己的文件中

"vue/one-component-per-file": "off",

// ↓在标签的右括号之前要求或不允许换行

"vue/html-closing-bracket-newline": "off",

// ↓强制每行的最大属性数

"vue/max-attributes-per-line": "off",

// ↓在多行元素的内容之前和之后需要换行

"vue/multiline-html-element-content-newline": "off",

// ↓在单行元素的内容之前和之后需要换行

"vue/singleline-html-element-content-newline": "off",

// ↓在模板中的自定义组件上实施属性命名样式

"vue/attribute-hyphenation": "off",

// ↓需要道具的默认值

"vue/require-default-prop": "off",

// ↓实施自我封闭的风格

// 'vue/html-self-closing': 'off',

"vue/html-self-closing": [

"error",

{

html: {

void: "always",

normal: "never",

component: "always",

},

svg: "always",

math: "always",

},

],

// 使用script-setup需要引入这个,当组件未使用或者变量未使用时做的操作

"vue/script-setup-uses-vars": "error",

},

});

```

  

增加 Elint 忽略文件，在这些地方禁用检查

  

`.eslintignore`

  

```

*.sh

node_modules

*.md

*.woff

*.ttf

.vscode

.idea

dist

/public

/docs

.husky

.local

/bin

Dockerfile

```

  

在`package.json`文件下`scripts`标签中添加运行脚本

  

```json

"lint:eslint": "eslint --cache --max-warnings 0 \"{src,mock}/**/*.{vue,ts,tsx}\" --fix",

```

  

配置完后可以通过命令 ： `pnpm run lint:eslint` 来检查项目内的格式错误

  

#### Prettier

  

添加配置文件: `prettier.config.cjs`

  

```js

// 配置详解 https://www.cnblogs.com/linjunfu/p/10880381.html

module.exports = {

// 超过最大值换行

printWidth: 100,

// tab缩进大小,默认为2

tabWidth: 2,

// 使用分号, 默认true

semi: false,

// 使用table缩进,关闭则使用空格

useTabs: false,

vueIndentScriptAndStyle: true,

// 使用单引号, 默认false(在jsx中配置无效, 默认都是双引号)

singleQuote: true,

// 引用对象中的属性时更改

quoteProps: 'as-needed',

// 在对象文字中打印括号之间的空格 { foo: bar }

bracketSpacing: true,

// 多行时尽可能打印尾随逗号。（例如，单行数组永远不会得到尾随逗号。）

trailingComma: 'es5',

// 多行 JSX 元素放在最后一行的末尾，而不是单独放在下一行（不适用于自闭元素）

jsxBracketSameLine: false,

// 在JSX中使用单引号而不是双引号。

jsxSingleQuote: false,

// 在单个箭头函数参数周围加上括号。

arrowParens: 'always',

// Prettier 可以在文件顶部插入一个特殊的 @format 标记，指定文件格式需要被格式化。

insertPragma: false,

// Prettier 可以将自己限制为仅在文件顶部格式化包含特殊注释（称为pragma）的文件。

requirePragma: false,

// 是否换行 Prose Wrap

proseWrap: 'never',

// 指定 HTML 文件的全局空白区域敏感度

htmlWhitespaceSensitivity: 'strict',

// 指定行尾序列

endOfLine: 'lf',

// 格式化开始的字符,从第0个开始

rangeStart: 0,

// 没有尾随逗号

trailingComma: 'none',

}

```

  

增加忽略文件，在这些地方禁用格式化

  

`.prettierignore`

  

```

/dist/*

.local

.output.js

/node_modules/**

  

**/*.svg

**/*.sh

  

/public/*

  

```

  

在 `package.json` 文件下 `scripts` 标签中添加运行脚本

  

```json

"lint:prettier": "prettier --write --loglevel warn \"src/**/*.{js,json,tsx,css,less,scss,vue,html,md}\"",

```

  

同样的，运行： `pnpm run lint:prettier` 就可以对项目的代码进行格式化

  

  

**`VS Code` 配置**

  

在项目根文件夹添加 `.vscode` 文件夹，添加 `settings.json` 就可以对本项目工作空间进行 `VS Code` 设置，不会影响其他项目

  

```json

{

"eslint.format.enable": true,

"editor.formatOnSave": true, //每次保存自动格式化

"editor.codeActionsOnSave": {

"source.fixAll.eslint": true // 每次保存的时候将代码按eslint格式进行修复

},

"[javascript]": {

"editor.defaultFormatter": "dbaeumer.vscode-eslint"

},

}

```

  

#### Stylelint

  

stylelint 用于校验项目内部 css 的风格,加上编辑器的自动修复，可以很好的统一项目内部 css 风格

  

项目中安装开发依赖

  

```bash

pnpm i stylelint stylelint-config-prettier stylelint-config-standard stylelint-order -D

```

  

- [stylelint官网](https://stylelint.io/)

- [stylelint的npm首页](https://www.npmjs.com/package/stylelint)

- [stylelint-config-standard的npm首页](https://www.npmjs.com/package/stylelint-config-standard)：扩展，标准库

- [stylelint-config-prettier的npm首页](https://www.npmjs.com/package/stylelint-config-prettier)：扩展，解决冲突的

- [stylelint-order的npm首页](https://www.npmjs.com/package/stylelint-order)：插件，样式排序

- [stylelinit的配置说明](https://stylelint.io/user-guide/configure#ignorefiles)

- [stylelint的配置规则](https://stylelint.io/user-guide/rules/list)

  

  

根目录 stylelint 配置文件 `stylelint.config.cjs`

  

```js

module.exports = {

root: true,

// ↓插件

plugins: ['stylelint-order'],

// ↓扩展

extends: ['stylelint-config-standard', 'stylelint-config-prettier'],

// ↓自定义规则

rules: {

// ↓禁止使用未知的伪类选择器。

'selector-pseudo-class-no-unknown': [

true,

{

ignorePseudoClasses: ['global']

}

],

'selector-pseudo-element-no-unknown': [

true,

{

ignorePseudoElements: ['v-deep']

}

],

// ↓禁止使用未知规则。

'at-rule-no-unknown': [

true,

{

ignoreAtRules: [

'tailwind',

'apply',

'variants',

'responsive',

'screen',

'function',

'if',

'each',

'include',

'mixin'

]

}

],

// ↓禁止空来源。

'no-empty-source': null,

// ↓禁止使用无效的命名网格区域。

'named-grid-areas-no-invalid': null,

// ↓要求或不允许使用Unicode字节顺序标记。

'unicode-bom': 'never',

// ↓禁止较低特异性的选择器在覆盖较高特异性的选择器之后出现。

'no-descending-specificity': null,

// ↓禁止在字体系列名称列表中缺少通用系列。

'font-family-no-missing-generic-family-keyword': null,

// ↓在声明的冒号后面需要一个空格或禁止空格。

'declaration-colon-space-after': 'always-single-line',

// ↓在声明的冒号之前需要一个空格或禁止使用空格。

'declaration-colon-space-before': 'never',

// ↓在声明块内要求或不允许尾随分号。

// 'declaration-block-trailing-semicolon': 'always',

// ↓在规则之前要求或禁止使用空行。

'rule-empty-line-before': [

'always',

{

ignore: ['after-comment', 'first-nested']

}

],

// ↓禁止使用未知单位。

'unit-no-unknown': [true, { ignoreUnits: ['rpx'] }],

// ↓样式顺序

'order/order': [

[

'dollar-variables',

'custom-properties',

'at-rules',

'declarations',

{

type: 'at-rule',

name: 'supports'

},

{

type: 'at-rule',

name: 'media'

},

'rules'

],

{ severity: 'warning' }

]

},

// ↓忽略检查的文件

ignoreFiles: ['**/*.js', '**/*.jsx', '**/*.tsx', '**/*.ts']

}

```

  

添加忽略文件 `.stylelintignore`

  

```

/dist/*

/public/*

public/*

```

  

在 `package.json` 文件下 `scripts` 标签中添加运行脚本

  

  

  

  

### 提交信息规范

  

  

  

在一个团队中，每个人的 git 的 commit 信息都不一样，五花八门，没有一个机制很难保证规范化，如何才能规范化呢？可能你想到的是 git 的 hook 机制，去写 shell 脚本去实现。这当然可以，其实 JavaScript 有一个很好的工具可以实现这个模板，它就是 commitlint。